---
layout: post
title: Java多线程之死锁
date: 2017-05-09
tag: 多线程
---

	当一组Java线程发生死锁时，Java应用程序无法从死锁中恢复过来。因此在设计时一定要排除那些可能导致死锁出现的条件。

#### 锁顺序死锁

	当两个线程试图以不同的顺序来获取相同的锁，那么就可能发生锁顺序死锁。

```
示例代码
public class LeftRightDeadlock {
	private final Object left = new Object();
	private final Object right = new Object();

	public void leftRight() {
		synchronized (left) {
			synchronized (right) {
				doSomething();
			}
		}
	}

	public void rightLeft() {
		synchronized (right) {
			synchronized (left) {
				doSomething();
			}
		}
	}
}
```

	如何避免：如果所有线程以固定的顺序来获得锁，那么在程序中就不会出现锁顺序死锁问题。在程序中始终使用开放调用（在调用某个方法时，不需要持有锁）。

#### 资源死锁
	当多个线程在相同的资源集合上等待时，也会发生死锁。
	另一种基于资源的死锁形式时线程饥饿死锁。一个示例，在一个单线程的Executor中，一个任务提交另一个任务，并等待被提交任务在Executor中执行完成。这种情况下，第一个任务将永远等待下去。有界线程池／资源池与相互依赖的任务不能一起使用。

#### 死锁的避免与诊断





